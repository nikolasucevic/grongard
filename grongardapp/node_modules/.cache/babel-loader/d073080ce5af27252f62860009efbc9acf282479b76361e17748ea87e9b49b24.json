{"ast":null,"code":"\"use client\";\n\n// packages/react/popper/src/Popper.tsx\nimport * as React from \"react\";\nimport { useFloating, autoUpdate, offset, shift, limitShift, hide, arrow as floatingUIarrow, flip, size } from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = props => {\n  const {\n    __scopePopper,\n    children\n  } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */jsx(PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor,\n    children\n  });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopper,\n    virtualRef,\n    ...anchorProps\n  } = props;\n  const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);\n  });\n  return virtualRef ? null : /* @__PURE__ */jsx(Primitive.div, {\n    ...anchorProps,\n    ref: composedRefs\n  });\n});\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef((props, forwardedRef) => {\n  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;\n  const {\n    __scopePopper,\n    side = \"bottom\",\n    sideOffset = 0,\n    align = \"center\",\n    alignOffset = 0,\n    arrowPadding = 0,\n    avoidCollisions = true,\n    collisionBoundary = [],\n    collisionPadding: collisionPaddingProp = 0,\n    sticky = \"partial\",\n    hideWhenDetached = false,\n    updatePositionStrategy = \"optimized\",\n    onPlaced,\n    ...contentProps\n  } = props;\n  const context = usePopperContext(CONTENT_NAME, __scopePopper);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [arrow, setArrow] = React.useState(null);\n  const arrowSize = useSize(arrow);\n  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;\n  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...collisionPaddingProp\n  };\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    isPositioned,\n    middlewareData\n  } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const cleanup = autoUpdate(...args, {\n        animationFrame: updatePositionStrategy === \"always\"\n      });\n      return cleanup;\n    },\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [offset({\n      mainAxis: sideOffset + arrowHeight,\n      alignmentAxis: alignOffset\n    }), avoidCollisions && shift({\n      mainAxis: true,\n      crossAxis: false,\n      limiter: sticky === \"partial\" ? limitShift() : void 0,\n      ...detectOverflowOptions\n    }), avoidCollisions && flip({\n      ...detectOverflowOptions\n    }), size({\n      ...detectOverflowOptions,\n      apply: _ref => {\n        let {\n          elements,\n          rects,\n          availableWidth,\n          availableHeight\n        } = _ref;\n        const {\n          width: anchorWidth,\n          height: anchorHeight\n        } = rects.reference;\n        const contentStyle = elements.floating.style;\n        contentStyle.setProperty(\"--radix-popper-available-width\", \"\".concat(availableWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-available-height\", \"\".concat(availableHeight, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-width\", \"\".concat(anchorWidth, \"px\"));\n        contentStyle.setProperty(\"--radix-popper-anchor-height\", \"\".concat(anchorHeight, \"px\"));\n      }\n    }), arrow && floatingUIarrow({\n      element: arrow,\n      padding: arrowPadding\n    }), transformOrigin({\n      arrowWidth,\n      arrowHeight\n    }), hideWhenDetached && hide({\n      strategy: \"referenceHidden\",\n      ...detectOverflowOptions\n    })]\n  });\n  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n  const handlePlaced = useCallbackRef(onPlaced);\n  useLayoutEffect(() => {\n    if (isPositioned) {\n      handlePlaced === null || handlePlaced === void 0 || handlePlaced();\n    }\n  }, [isPositioned, handlePlaced]);\n  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;\n  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;\n  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: {\n      ...floatingStyles,\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [(_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x, (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y].join(\" \"),\n      // hide the content if using the hide middleware and should be hidden\n      // set visibility to hidden and disable pointer events so the UI behaves\n      // as if the PopperContent isn't there at all\n      ...(((_middlewareData$hide = middlewareData.hide) === null || _middlewareData$hide === void 0 ? void 0 : _middlewareData$hide.referenceHidden) && {\n        visibility: \"hidden\",\n        pointerEvents: \"none\"\n      })\n    },\n    dir: props.dir,\n    children: /* @__PURE__ */jsx(PopperContentProvider, {\n      scope: __scopePopper,\n      placedSide,\n      onArrowChange: setArrow,\n      arrowX,\n      arrowY,\n      shouldHideArrow: cannotCenterArrow,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        \"data-side\": placedSide,\n        \"data-align\": placedAlign,\n        ...contentProps,\n        ref: composedRefs,\n        style: {\n          ...contentProps.style,\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned ? \"none\" : void 0\n        }\n      })\n    })\n  });\n});\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const {\n    __scopePopper,\n    ...arrowProps\n  } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */\n    jsx(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: \"rotate(180deg)\",\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      },\n      children: /* @__PURE__ */jsx(ArrowPrimitive.Root, {\n        ...arrowProps,\n        ref: forwardedRef,\n        style: {\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: \"block\"\n        }\n      })\n    })\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = options => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;\n    const {\n      placement,\n      rects,\n      middlewareData\n    } = data;\n    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;\n    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(-arrowHeight, \"px\");\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : \"\".concat(arrowXCenter, \"px\");\n      y = \"\".concat(rects.floating.height + arrowHeight, \"px\");\n    } else if (placedSide === \"right\") {\n      x = \"\".concat(-arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    } else if (placedSide === \"left\") {\n      x = \"\".concat(rects.floating.width + arrowHeight, \"px\");\n      y = isArrowHidden ? noArrowAlign : \"\".concat(arrowYCenter, \"px\");\n    }\n    return {\n      data: {\n        x,\n        y\n      }\n    };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, PopperArrow, PopperContent, Root2 as Root, SIDE_OPTIONS, createPopperScope };","map":{"version":3,"names":["React","useFloating","autoUpdate","offset","shift","limitShift","hide","arrow","floatingUIarrow","flip","size","ArrowPrimitive","useComposedRefs","createContextScope","Primitive","useCallbackRef","useLayoutEffect","useSize","jsx","SIDE_OPTIONS","ALIGN_OPTIONS","POPPER_NAME","createPopperContext","createPopperScope","PopperProvider","usePopperContext","Popper","props","__scopePopper","children","anchor","setAnchor","useState","scope","onAnchorChange","displayName","ANCHOR_NAME","PopperAnchor","forwardRef","forwardedRef","virtualRef","anchorProps","context","ref","useRef","composedRefs","useEffect","current","div","CONTENT_NAME","PopperContentProvider","useContentContext","PopperContent","_arrowSize$width","_arrowSize$height","_middlewareData$arrow","_middlewareData$arrow2","_middlewareData$arrow3","_middlewareData$trans","_middlewareData$trans2","_middlewareData$hide","side","sideOffset","align","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","collisionPadding","collisionPaddingProp","sticky","hideWhenDetached","updatePositionStrategy","onPlaced","contentProps","content","setContent","node","setArrow","arrowSize","arrowWidth","width","arrowHeight","height","desiredPlacement","top","right","bottom","left","boundary","Array","isArray","hasExplicitBoundaries","length","detectOverflowOptions","padding","filter","isNotNull","altBoundary","refs","floatingStyles","placement","isPositioned","middlewareData","strategy","whileElementsMounted","_len","arguments","args","_key","cleanup","animationFrame","elements","reference","middleware","mainAxis","alignmentAxis","crossAxis","limiter","apply","_ref","rects","availableWidth","availableHeight","anchorWidth","anchorHeight","contentStyle","floating","style","setProperty","concat","element","transformOrigin","placedSide","placedAlign","getSideAndAlignFromPlacement","handlePlaced","arrowX","x","arrowY","y","cannotCenterArrow","centerOffset","contentZIndex","setContentZIndex","window","getComputedStyle","zIndex","setFloating","transform","minWidth","join","referenceHidden","visibility","pointerEvents","dir","onArrowChange","shouldHideArrow","animation","ARROW_NAME","OPPOSITE_SIDE","PopperArrow","PopperArrow2","arrowProps","contentContext","baseSide","position","Root","display","value","options","name","fn","data","_middlewareData$arrow4","_middlewareData$arrow5","_middlewareData$arrow6","_middlewareData$arrow7","_middlewareData$arrow8","isArrowHidden","noArrowAlign","start","center","end","arrowXCenter","arrowYCenter","split","Root2","Anchor","Content","Arrow"],"sources":["/Users/nikola/Downloads/grass/grongardapp/node_modules/@radix-ui/react-popper/src/Popper.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ElementRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ElementRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n"],"mappings":";;;AAAA,YAAYA,KAAA,MAAW;AACvB,SACEC,WAAA,EACAC,UAAA,EACAC,MAAA,EACAC,KAAA,EACAC,UAAA,EACAC,IAAA,EACAC,KAAA,IAASC,eAAA,EACTC,IAAA,EACAC,IAAA,QACK;AACP,YAAYC,cAAA,MAAoB;AAChC,SAASC,eAAA,QAAuB;AAChC,SAASC,kBAAA,QAA0B;AACnC,SAASC,SAAA,QAAiB;AAC1B,SAASC,cAAA,QAAsB;AAC/B,SAASC,eAAA,QAAuB;AAChC,SAASC,OAAA,QAAe;AAkCpB,SAAAC,GAAA;AA5BJ,IAAMC,YAAA,GAAe,CAAC,OAAO,SAAS,UAAU,MAAM;AACtD,IAAMC,aAAA,GAAgB,CAAC,SAAS,UAAU,KAAK;AAS/C,IAAMC,WAAA,GAAc;AAGpB,IAAM,CAACC,mBAAA,EAAqBC,iBAAiB,IAAIV,kBAAA,CAAmBQ,WAAW;AAM/E,IAAM,CAACG,cAAA,EAAgBC,gBAAgB,IAAIH,mBAAA,CAAwCD,WAAW;AAK9F,IAAMK,MAAA,GAAiCC,KAAA,IAAoC;EACzE,MAAM;IAAEC,aAAA;IAAeC;EAAS,IAAIF,KAAA;EACpC,MAAM,CAACG,MAAA,EAAQC,SAAS,IAAU/B,KAAA,CAAAgC,QAAA,CAA4B,IAAI;EAClE,OACE,eAAAd,GAAA,CAACM,cAAA;IAAeS,KAAA,EAAOL,aAAA;IAAeE,MAAA;IAAgBI,cAAA,EAAgBH,SAAA;IACnEF;EAAA,CACH;AAEJ;AAEAH,MAAA,CAAOS,WAAA,GAAcd,WAAA;AAMrB,IAAMe,WAAA,GAAc;AAQpB,IAAMC,YAAA,GAAqBrC,KAAA,CAAAsC,UAAA,CACzB,CAACX,KAAA,EAAuCY,YAAA,KAAiB;EACvD,MAAM;IAAEX,aAAA;IAAeY,UAAA;IAAY,GAAGC;EAAY,IAAId,KAAA;EACtD,MAAMe,OAAA,GAAUjB,gBAAA,CAAiBW,WAAA,EAAaR,aAAa;EAC3D,MAAMe,GAAA,GAAY3C,KAAA,CAAA4C,MAAA,CAA4B,IAAI;EAClD,MAAMC,YAAA,GAAejC,eAAA,CAAgB2B,YAAA,EAAcI,GAAG;EAEhD3C,KAAA,CAAA8C,SAAA,CAAU,MAAM;IAIpBJ,OAAA,CAAQR,cAAA,CAAe,CAAAM,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYO,OAAA,KAAWJ,GAAA,CAAII,OAAO;EAC3D,CAAC;EAED,OAAOP,UAAA,GAAa,OAAO,eAAAtB,GAAA,CAACJ,SAAA,CAAUkC,GAAA,EAAV;IAAe,GAAGP,WAAA;IAAaE,GAAA,EAAKE;EAAA,CAAc;AAChF,CACF;AAEAR,YAAA,CAAaF,WAAA,GAAcC,WAAA;AAM3B,IAAMa,YAAA,GAAe;AAUrB,IAAM,CAACC,qBAAA,EAAuBC,iBAAiB,IAC7C7B,mBAAA,CAA+C2B,YAAY;AAoB7D,IAAMG,aAAA,GAAsBpD,KAAA,CAAAsC,UAAA,CAC1B,CAACX,KAAA,EAAwCY,YAAA,KAAiB;EAAA,IAAAc,gBAAA,EAAAC,iBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,oBAAA;EACxD,MAAM;IACJhC,aAAA;IACAiC,IAAA,GAAO;IACPC,UAAA,GAAa;IACbC,KAAA,GAAQ;IACRC,WAAA,GAAc;IACdC,YAAA,GAAe;IACfC,eAAA,GAAkB;IAClBC,iBAAA,GAAoB,EAAC;IACrBC,gBAAA,EAAkBC,oBAAA,GAAuB;IACzCC,MAAA,GAAS;IACTC,gBAAA,GAAmB;IACnBC,sBAAA,GAAyB;IACzBC,QAAA;IACA,GAAGC;EACL,IAAI/C,KAAA;EAEJ,MAAMe,OAAA,GAAUjB,gBAAA,CAAiBwB,YAAA,EAAcrB,aAAa;EAE5D,MAAM,CAAC+C,OAAA,EAASC,UAAU,IAAU5E,KAAA,CAAAgC,QAAA,CAAgC,IAAI;EACxE,MAAMa,YAAA,GAAejC,eAAA,CAAgB2B,YAAA,EAAesC,IAAA,IAASD,UAAA,CAAWC,IAAI,CAAC;EAE7E,MAAM,CAACtE,KAAA,EAAOuE,QAAQ,IAAU9E,KAAA,CAAAgC,QAAA,CAAiC,IAAI;EACrE,MAAM+C,SAAA,GAAY9D,OAAA,CAAQV,KAAK;EAC/B,MAAMyE,UAAA,IAAA3B,gBAAA,GAAa0B,SAAA,aAAAA,SAAA,uBAAAA,SAAA,CAAWE,KAAA,cAAA5B,gBAAA,cAAAA,gBAAA,GAAS;EACvC,MAAM6B,WAAA,IAAA5B,iBAAA,GAAcyB,SAAA,aAAAA,SAAA,uBAAAA,SAAA,CAAWI,MAAA,cAAA7B,iBAAA,cAAAA,iBAAA,GAAU;EAEzC,MAAM8B,gBAAA,GAAoBvB,IAAA,IAAQE,KAAA,KAAU,WAAW,MAAMA,KAAA,GAAQ;EAErE,MAAMK,gBAAA,GACJ,OAAOC,oBAAA,KAAyB,WAC5BA,oBAAA,GACA;IAAEgB,GAAA,EAAK;IAAGC,KAAA,EAAO;IAAGC,MAAA,EAAQ;IAAGC,IAAA,EAAM;IAAG,GAAGnB;EAAqB;EAEtE,MAAMoB,QAAA,GAAWC,KAAA,CAAMC,OAAA,CAAQxB,iBAAiB,IAAIA,iBAAA,GAAoB,CAACA,iBAAiB;EAC1F,MAAMyB,qBAAA,GAAwBH,QAAA,CAASI,MAAA,GAAS;EAEhD,MAAMC,qBAAA,GAAwB;IAC5BC,OAAA,EAAS3B,gBAAA;IACTqB,QAAA,EAAUA,QAAA,CAASO,MAAA,CAAOC,SAAS;IAAA;IAEnCC,WAAA,EAAaN;EACf;EAEA,MAAM;IAAEO,IAAA;IAAMC,cAAA;IAAgBC,SAAA;IAAWC,YAAA;IAAcC;EAAe,IAAItG,WAAA,CAAY;IAAA;IAEpFuG,QAAA,EAAU;IACVH,SAAA,EAAWjB,gBAAA;IACXqB,oBAAA,EAAsB,SAAAA,CAAA,EAAa;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAd,MAAA,EAATe,IAAA,OAAAlB,KAAA,CAAAgB,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAAD,IAAA,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;MAAA;MACxB,MAAMC,OAAA,GAAU5G,UAAA,CAAW,GAAG0G,IAAA,EAAM;QAClCG,cAAA,EAAgBvC,sBAAA,KAA2B;MAC7C,CAAC;MACD,OAAOsC,OAAA;IACT;IACAE,QAAA,EAAU;MACRC,SAAA,EAAWvE,OAAA,CAAQZ;IACrB;IACAoF,UAAA,EAAY,CACV/G,MAAA,CAAO;MAAEgH,QAAA,EAAUrD,UAAA,GAAaoB,WAAA;MAAakC,aAAA,EAAepD;IAAY,CAAC,GACzEE,eAAA,IACE9D,KAAA,CAAM;MACJ+G,QAAA,EAAU;MACVE,SAAA,EAAW;MACXC,OAAA,EAAShD,MAAA,KAAW,YAAYjE,UAAA,CAAW,IAAI;MAC/C,GAAGyF;IACL,CAAC,GACH5B,eAAA,IAAmBzD,IAAA,CAAK;MAAE,GAAGqF;IAAsB,CAAC,GACpDpF,IAAA,CAAK;MACH,GAAGoF,qBAAA;MACHyB,KAAA,EAAOC,IAAA,IAA0D;QAAA,IAAzD;UAAER,QAAA;UAAUS,KAAA;UAAOC,cAAA;UAAgBC;QAAgB,IAAAH,IAAA;QACzD,MAAM;UAAEvC,KAAA,EAAO2C,WAAA;UAAazC,MAAA,EAAQ0C;QAAa,IAAIJ,KAAA,CAAMR,SAAA;QAC3D,MAAMa,YAAA,GAAed,QAAA,CAASe,QAAA,CAASC,KAAA;QACvCF,YAAA,CAAaG,WAAA,CAAY,qCAAAC,MAAA,CAAqCR,cAAc,OAAI;QAChFI,YAAA,CAAaG,WAAA,CAAY,sCAAAC,MAAA,CAAsCP,eAAe,OAAI;QAClFG,YAAA,CAAaG,WAAA,CAAY,kCAAAC,MAAA,CAAkCN,WAAW,OAAI;QAC1EE,YAAA,CAAaG,WAAA,CAAY,mCAAAC,MAAA,CAAmCL,YAAY,OAAI;MAC9E;IACF,CAAC,GACDtH,KAAA,IAASC,eAAA,CAAgB;MAAE2H,OAAA,EAAS5H,KAAA;MAAOwF,OAAA,EAAS9B;IAAa,CAAC,GAClEmE,eAAA,CAAgB;MAAEpD,UAAA;MAAYE;IAAY,CAAC,GAC3CX,gBAAA,IAAoBjE,IAAA,CAAK;MAAEkG,QAAA,EAAU;MAAmB,GAAGV;IAAsB,CAAC;EAEtF,CAAC;EAED,MAAM,CAACuC,UAAA,EAAYC,WAAW,IAAIC,4BAAA,CAA6BlC,SAAS;EAExE,MAAMmC,YAAA,GAAezH,cAAA,CAAe0D,QAAQ;EAC5CzD,eAAA,CAAgB,MAAM;IACpB,IAAIsF,YAAA,EAAc;MAChBkC,YAAA,aAAAA,YAAA,eAAAA,YAAA,CAAe;IACjB;EACF,GAAG,CAAClC,YAAA,EAAckC,YAAY,CAAC;EAE/B,MAAMC,MAAA,IAAAlF,qBAAA,GAASgD,cAAA,CAAehG,KAAA,cAAAgD,qBAAA,uBAAfA,qBAAA,CAAsBmF,CAAA;EACrC,MAAMC,MAAA,IAAAnF,sBAAA,GAAS+C,cAAA,CAAehG,KAAA,cAAAiD,sBAAA,uBAAfA,sBAAA,CAAsBoF,CAAA;EACrC,MAAMC,iBAAA,GAAoB,EAAApF,sBAAA,GAAA8C,cAAA,CAAehG,KAAA,cAAAkD,sBAAA,uBAAfA,sBAAA,CAAsBqF,YAAA,MAAiB;EAEjE,MAAM,CAACC,aAAA,EAAeC,gBAAgB,IAAUhJ,KAAA,CAAAgC,QAAA,CAAiB;EACjEhB,eAAA,CAAgB,MAAM;IACpB,IAAI2D,OAAA,EAASqE,gBAAA,CAAiBC,MAAA,CAAOC,gBAAA,CAAiBvE,OAAO,EAAEwE,MAAM;EACvE,GAAG,CAACxE,OAAO,CAAC;EAEZ,OACE,eAAAzD,GAAA,CAAC;IACCyB,GAAA,EAAKwD,IAAA,CAAKiD,WAAA;IACV,qCAAkC;IAClCpB,KAAA,EAAO;MACL,GAAG5B,cAAA;MACHiD,SAAA,EAAW/C,YAAA,GAAeF,cAAA,CAAeiD,SAAA,GAAY;MAAA;MACrDC,QAAA,EAAU;MACVH,MAAA,EAAQJ,aAAA;MACR,CAAC,iCAAwC,GAAG,EAAArF,qBAAA,GAC1C6C,cAAA,CAAe6B,eAAA,cAAA1E,qBAAA,uBAAfA,qBAAA,CAAgCgF,CAAA,GAAA/E,sBAAA,GAChC4C,cAAA,CAAe6B,eAAA,cAAAzE,sBAAA,uBAAfA,sBAAA,CAAgCiF,CAAA,CAClC,CAAEW,IAAA,CAAK,GAAG;MAAA;MAAA;MAAA;MAKV,IAAI,EAAA3F,oBAAA,GAAA2C,cAAA,CAAejG,IAAA,cAAAsD,oBAAA,uBAAfA,oBAAA,CAAqB4F,eAAA,KAAmB;QAC1CC,UAAA,EAAY;QACZC,aAAA,EAAe;MACjB;IACF;IAIAC,GAAA,EAAKhI,KAAA,CAAMgI,GAAA;IAEX9H,QAAA,iBAAAX,GAAA,CAACgC,qBAAA;MACCjB,KAAA,EAAOL,aAAA;MACPyG,UAAA;MACAuB,aAAA,EAAe9E,QAAA;MACf2D,MAAA;MACAE,MAAA;MACAkB,eAAA,EAAiBhB,iBAAA;MAEjBhH,QAAA,iBAAAX,GAAA,CAACJ,SAAA,CAAUkC,GAAA,EAAV;QACC,aAAWqF,UAAA;QACX,cAAYC,WAAA;QACX,GAAG5D,YAAA;QACJ/B,GAAA,EAAKE,YAAA;QACLmF,KAAA,EAAO;UACL,GAAGtD,YAAA,CAAasD,KAAA;UAAA;UAAA;UAGhB8B,SAAA,EAAW,CAACxD,YAAA,GAAe,SAAS;QACtC;MAAA,CACF;IAAA,CACF;EAAA,CACF;AAEJ,CACF;AAEAlD,aAAA,CAAcjB,WAAA,GAAcc,YAAA;AAM5B,IAAM8G,UAAA,GAAa;AAEnB,IAAMC,aAAA,GAAoC;EACxC3E,GAAA,EAAK;EACLC,KAAA,EAAO;EACPC,MAAA,EAAQ;EACRC,IAAA,EAAM;AACR;AAMA,IAAMyE,WAAA,GAAoBjK,KAAA,CAAAsC,UAAA,CAAiD,SAAS4H,aAClFvI,KAAA,EACAY,YAAA,EACA;EACA,MAAM;IAAEX,aAAA;IAAe,GAAGuI;EAAW,IAAIxI,KAAA;EACzC,MAAMyI,cAAA,GAAiBjH,iBAAA,CAAkB4G,UAAA,EAAYnI,aAAa;EAClE,MAAMyI,QAAA,GAAWL,aAAA,CAAcI,cAAA,CAAe/B,UAAU;EAExD;IAAA;IAAA;IAAA;IAIE;IAAAnH,GAAA,CAAC;MACCyB,GAAA,EAAKyH,cAAA,CAAeR,aAAA;MACpB5B,KAAA,EAAO;QACLsC,QAAA,EAAU;QACV9E,IAAA,EAAM4E,cAAA,CAAe3B,MAAA;QACrBpD,GAAA,EAAK+E,cAAA,CAAezB,MAAA;QACpB,CAAC0B,QAAQ,GAAG;QACZjC,eAAA,EAAiB;UACf/C,GAAA,EAAK;UACLC,KAAA,EAAO;UACPC,MAAA,EAAQ;UACRC,IAAA,EAAM;QACR,EAAE4E,cAAA,CAAe/B,UAAU;QAC3BgB,SAAA,EAAW;UACThE,GAAA,EAAK;UACLC,KAAA,EAAO;UACPC,MAAA,kBAAQ;UACRC,IAAA,EAAM;QACR,EAAE4E,cAAA,CAAe/B,UAAU;QAC3BoB,UAAA,EAAYW,cAAA,CAAeP,eAAA,GAAkB,WAAW;MAC1D;MAEAhI,QAAA,iBAAAX,GAAA,CAAgBP,cAAA,CAAA4J,IAAA,EAAf;QACE,GAAGJ,UAAA;QACJxH,GAAA,EAAKJ,YAAA;QACLyF,KAAA,EAAO;UACL,GAAGmC,UAAA,CAAWnC,KAAA;UAAA;UAEdwC,OAAA,EAAS;QACX;MAAA,CACF;IAAA,CACF;EAAA;AAEJ,CAAC;AAEDP,WAAA,CAAY9H,WAAA,GAAc4H,UAAA;AAI1B,SAAS9D,UAAawE,KAAA,EAA6B;EACjD,OAAOA,KAAA,KAAU;AACnB;AAEA,IAAMrC,eAAA,GAAmBsC,OAAA,KAAsE;EAC7FC,IAAA,EAAM;EACND,OAAA;EACAE,GAAGC,IAAA,EAAM;IAAA,IAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA;IACP,MAAM;MAAE7E,SAAA;MAAWoB,KAAA;MAAOlB;IAAe,IAAIsE,IAAA;IAE7C,MAAMhC,iBAAA,GAAoB,EAAAiC,sBAAA,GAAAvE,cAAA,CAAehG,KAAA,cAAAuK,sBAAA,uBAAfA,sBAAA,CAAsBhC,YAAA,MAAiB;IACjE,MAAMqC,aAAA,GAAgBtC,iBAAA;IACtB,MAAM7D,UAAA,GAAamG,aAAA,GAAgB,IAAIT,OAAA,CAAQ1F,UAAA;IAC/C,MAAME,WAAA,GAAciG,aAAA,GAAgB,IAAIT,OAAA,CAAQxF,WAAA;IAEhD,MAAM,CAACmD,UAAA,EAAYC,WAAW,IAAIC,4BAAA,CAA6BlC,SAAS;IACxE,MAAM+E,YAAA,GAAe;MAAEC,KAAA,EAAO;MAAMC,MAAA,EAAQ;MAAOC,GAAA,EAAK;IAAO,EAAEjD,WAAW;IAE5E,MAAMkD,YAAA,KAAAT,sBAAA,IAAAC,sBAAA,GAAgBzE,cAAA,CAAehG,KAAA,cAAAyK,sBAAA,uBAAfA,sBAAA,CAAsBtC,CAAA,cAAAqC,sBAAA,cAAAA,sBAAA,GAAK,KAAK/F,UAAA,GAAa;IACnE,MAAMyG,YAAA,KAAAR,sBAAA,IAAAC,sBAAA,GAAgB3E,cAAA,CAAehG,KAAA,cAAA2K,sBAAA,uBAAfA,sBAAA,CAAsBtC,CAAA,cAAAqC,sBAAA,cAAAA,sBAAA,GAAK,KAAK/F,WAAA,GAAc;IAEpE,IAAIwD,CAAA,GAAI;IACR,IAAIE,CAAA,GAAI;IAER,IAAIP,UAAA,KAAe,UAAU;MAC3BK,CAAA,GAAIyC,aAAA,GAAgBC,YAAA,MAAAlD,MAAA,CAAkBsD,YAAY;MAClD5C,CAAA,MAAAV,MAAA,CAAO,CAAChD,WAAW;IACrB,WAAWmD,UAAA,KAAe,OAAO;MAC/BK,CAAA,GAAIyC,aAAA,GAAgBC,YAAA,MAAAlD,MAAA,CAAkBsD,YAAY;MAClD5C,CAAA,MAAAV,MAAA,CAAOT,KAAA,CAAMM,QAAA,CAAS5C,MAAA,GAASD,WAAW;IAC5C,WAAWmD,UAAA,KAAe,SAAS;MACjCK,CAAA,MAAAR,MAAA,CAAO,CAAChD,WAAW;MACnB0D,CAAA,GAAIuC,aAAA,GAAgBC,YAAA,MAAAlD,MAAA,CAAkBuD,YAAY;IACpD,WAAWpD,UAAA,KAAe,QAAQ;MAChCK,CAAA,MAAAR,MAAA,CAAOT,KAAA,CAAMM,QAAA,CAAS9C,KAAA,GAAQC,WAAW;MACzC0D,CAAA,GAAIuC,aAAA,GAAgBC,YAAA,MAAAlD,MAAA,CAAkBuD,YAAY;IACpD;IACA,OAAO;MAAEZ,IAAA,EAAM;QAAEnC,CAAA;QAAGE;MAAE;IAAE;EAC1B;AACF;AAEA,SAASL,6BAA6BlC,SAAA,EAAsB;EAC1D,MAAM,CAACxC,IAAA,EAAME,KAAA,GAAQ,QAAQ,IAAIsC,SAAA,CAAUqF,KAAA,CAAM,GAAG;EACpD,OAAO,CAAC7H,IAAA,EAAcE,KAAc;AACtC;AAEA,IAAM4H,KAAA,GAAOjK,MAAA;AACb,IAAMkK,MAAA,GAASvJ,YAAA;AACf,IAAMwJ,OAAA,GAAUzI,aAAA;AAChB,IAAM0I,KAAA,GAAQ7B,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}