{"ast":null,"code":"\"use client\";\n\n// packages/react/toast/src/Toast.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(\"Invalid prop `label` supplied to `\".concat(PROVIDER_NAME, \"`. Expected non-empty `string`.\"));\n  }\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      var _ref$current;\n      const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(_ref => {\n    let {\n      tabbingDirection\n    } = _ref;\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            var _headFocusProxyRef$cu;\n            (_headFocusProxyRef$cu = headFocusProxyRef.current) === null || _headFocusProxyRef$cu === void 0 || _headFocusProxyRef$cu.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            var _headFocusProxyRef$cu2, _tailFocusProxyRef$cu;\n            isTabbingBackwards ? (_headFocusProxyRef$cu2 = headFocusProxyRef.current) === null || _headFocusProxyRef$cu2 === void 0 ? void 0 : _headFocusProxyRef$cu2.focus() : (_tailFocusProxyRef$cu = tailFocusProxyRef.current) === null || _tailFocusProxyRef$cu === void 0 ? void 0 : _tailFocusProxyRef$cu.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      var _context$viewport;\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !((_context$viewport = context.viewport) !== null && _context$viewport !== void 0 && _context$viewport.contains(prevFocusedElement));\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open = true, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", \"\".concat(x, \"px\"));\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", \"\".concat(y, \"px\"));\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", \"\".concat(x, \"px\"));\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", \"\".concat(y, \"px\"));\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    var _context$viewport2;\n    const isFocusInToast = node === null || node === void 0 ? void 0 : node.contains(document.activeElement);\n    if (isFocusInToast) (_context$viewport2 = context.viewport) === null || _context$viewport2 === void 0 || _context$viewport2.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = ( /* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume === null || onResume === void 0 || onResume();\n      };\n      const handlePause = () => {\n        const elapsedTime = ( /* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause === null || onPause === void 0 || onPause();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal( /* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, {\n      ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n  if (!altText.trim()) {\n    console.error(\"Invalid prop `altText` supplied to `\".concat(ACTION_NAME, \"`. Expected non-empty `string`.\"));\n    return null;\n  }\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, {\n      ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, _ref2) {\n  let {\n    discrete\n  } = _ref2;\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = function (delta, direction) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame() {\n  let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };","map":{"version":3,"names":["React","ReactDOM","composeEventHandlers","useComposedRefs","createCollection","createContextScope","DismissableLayer","Portal","Presence","Primitive","dispatchDiscreteCustomEvent","useCallbackRef","useControllableState","useLayoutEffect","VisuallyHidden","Fragment","jsx","jsxs","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createToastContext","createToastScope","ToastProviderProvider","useToastProviderContext","ToastProvider","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","useState","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","useRef","isClosePausedRef","trim","console","error","concat","Provider","scope","onViewportChange","onToastAdd","useCallback","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","ToastViewport","forwardRef","forwardedRef","hotkey","viewportProps","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","hotkeyLabel","join","replace","hasToasts","useEffect","handleKeyDown","event","_ref$current","isHotkeyPressed","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","_ref","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","_headFocusProxyRef$cu","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","_headFocusProxyRef$cu2","_tailFocusProxyRef$cu","Branch","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","ol","FOCUS_PROXY_NAME","proxyProps","position","onFocus","_context$viewport","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","Toast","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","setOpen","prop","defaultProp","onChange","present","ToastImpl","onClose","onPause","onResume","onSwipeStart","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","node","setNode","node2","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","_context$viewport2","isFocusInToast","startTimer","duration2","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","useMemo","getAnnounceTextContent","ToastAnnounce","createPortal","ItemSlot","Root","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","event2","once","announceProps","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","TITLE_NAME","ToastTitle","titleProps","div","DESCRIPTION_NAME","ToastDescription","descriptionProps","ACTION_NAME","ToastAction","altText","actionProps","ToastAnnounceExclude","ToastClose","CLOSE_NAME","closeProps","interactiveContext","onClick","announceExcludeProps","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","_ref2","bubbles","cancelable","direction","threshold","arguments","length","undefined","deltaX","deltaY","isDeltaX","callback","fn","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some","Viewport","Root2","Title","Description","Action","Close"],"sources":["/Users/nikola/Downloads/grass/grongardapp/node_modules/@radix-ui/react-toast/src/Toast.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ElementRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed = hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open = true, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ElementRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}